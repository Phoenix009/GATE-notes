File Organization:
    -- Database are stored physically as file of records which are typically stored on magnetic disks
    -- Records are a collection of field values
    -- Database --> Files --> Records --> Fields

Record blocking and Spanned and Unspanned records:
    -- The records of a file must be allocate to disk blocks as block is the unit of data transfer between disk and memory
    -- When the block size is greater than the record size, each block will contain numerous records
    
       blocking_factor (bfr) = floor(block_size / record_size)
    
    -- The blocking factor is the number of fixed size records that can be stored in a single block
    -- In general the record size may not divide the block size, so we have some unused space
    
       free_space = B - (bfr*record_size)
    
    -- To use this unused space we can store the aprt of a record on one block and the rest on another
    -- A pointer at the end of the first block points to the block containing the remainder of the record.
    -- This organization is called the Spanned Organization as the records can span more than one block.
    -- If the records are not allowed to span more than one block then the organization is called unspanned organization

    -- Spanned organization is suitable when the average record size is greater than the block size to reduce the lost space in blocks
    -- Unspanned organization is used when the blocks are fized size and block size is greater.

Files of Unordered Records (Heap/Pile Files):
    -- Simplest and most basic type of roganization.
    -- Records are placed in the file in the order in which they are inserted, so new recods are inserted at the end of the file.
    -- Insering is very efficient. The last block of the files is copied to the buffer, new record is added, and the block is rewritten to the disk
    -- Searching for a record involves linear search through file block by block.

Files of Ordered Records (Sorted Files):
    -- We can physically order the records of a file on disk based on the values of one of their fields called ordering field.
    -- This leads to an ordered or sequential file.
    -- If the ordering field is also a key field (a field guaranteed to have unique values) then the field is called the ordering key for the file.

Dense and Sparse Index:
    -- Indexes can be characterized as dense and sparse.
    -- A Dense index has an index entry for every search key in the data file.
    -- A sparse index on the other hand has index entries for only some of the search values

Primary Indexes:
    -- A primary index is an ordered file whose records are of fized length with two fields.
    -- The first field is of the same data type as the ordering key field, and the second field is a pointer to a disk block.
    -- There is one index entry for the first record in each block and a pointer to that block as its two fields.
    -- The first record in the each block is called the anchor record or the block anchor.
    -- Thus, the primary index is a sparse index as it includes an entry for each anchor of a block rather than for every search value.
    -- The total number of entries in the index is equal to the number of blocks in the ordered data file.
    -- If the primary index file contains only bi blocks, then to locate a record with a search key requires a binary search of that index and access to the block: a total of log2(bi) + 1

    -- A major problem with a primary index is the insertion and deletion of records.
    -- With primary index the issue is compounded because to insert a record, we must not only move the records to make space but also change some of the index entries, since moving records will change the anchor records for some blocks.

Clustering Indexes:
    -- If the file records are physically ordered on an non key field which does not have a distinct values for each records that field is called the clustering field and the data file is called a clustered file.
    -- We can create index called a clustering index to speed up the retrieval of all the records that have the same value for the clustering field.
    -- This differs from the primary index which requires that the ordering field of the data file have a distinct values for each record.
    -- A clustering index is also an ordered file with two fields
    -- the first field is of the same type as the clustering field of the data file and the second field is the disk block pointer.
    -- There is one entry in the clustering index for each distinct value of the clustering field, and it containst the pointer to the first block in the data file that has a record with that value for the clustering field.
    -- A clustering index is another example of a sparse index.

Secondary Indexes: 
    -- A secondary index provides a secondary means of accessing a data file for which some primary access already exists.
    -- The data file records could be ordered unordered or hashed.
    -- The secondary index may be created on a field that is a candidate key and has a unique value in every record or a non key field with duplicate values
    -- The index is an ordered file with two fields. the first field is of the same data type as the indexing field and the second field is either a block or a record pointer.
    
    -- First we consider a secondary index access strucuture on a key field that has a distinct value for every record. such a field is called a secondary key
    -- In this case there is one index entry for each record in the data file, which contains the value of the field record and a pointer to the block or the record itself.
    -- Hence, Such an index is dense.

    -- We can also create secondary index on a nonkey or nonordering field of a file. In this case numerous records in the data file can have the same value for the indexing field.
    -- There are several options to implement such an index.
        1. We can include duplicate index entries with the same key value on for each record. This would be a dense index.
        2. We can create variable length records for the index entries with a repeating field for the pointer, one poniter for each block that contains a record whose indexing field value is equal to the key.
        3. Option 3 which is most commonly used, the index entries are fixed length and have a single entry for each key of the indexing field, but create an extra level of indirection to handle the multiple pointers
            In this the pointer field in the index entry points to a diskblock that contains a set of record pointers to the records with the indexing field equal to the key value.

NOTE:
    -- The secondary index provides a logical ordering on the records by the indexing field.
    -- If we access records in the order of the entries in the secondary index, we get them in order of the indexing field.
    -- The primary and the clustering index assume that the records in the file are physically ordered on the indexing field.


Multilevel Indexing:
    -- A multilevel indexing considers the index file, which we will now refer to as the first or base level of a multilevel index, as an ordered file with a distinct value for each key.
    -- By considering the fist level index file as a sorted file, we can create a primary index for the first level; this index to the first level is called the second level of the multilevel index.
    -- Because the second level is a primary index, we can use block anchors so that the second level has one entry for each block of the first level.
    -- The blocking factor for the second level and for all the subsequent block is the same as that for the first level index because all index entries are of the same size.
    -- This blocking factor is also referred to as the fan-out value in multilevel indexing
    -- We can repeat the preceeding process until all the entries of some index level 't' fit in a single block. This index level is called the top level index.
    -- Hence, a multilevel index with r1 first level entries will have approximately t levels where
        t = ceil(math.log2(r1))
    -- When searching a key in the multilevel indexing one block is accesses at each level. Hence, t diskblocks are accessed for an index search where 't' is the number of index levels.
    -- The multilevel scheme described here can be used on any type of index whether it is primary, clustering or secondary as long as the first level has distinct values for key and fixed length entries.

BTrees:
    -- A btree when used as an access structure on a key field to searc for records in a data file, can be defined as follows:
        1. Each internal node in the Btree is of the form:
            <P1, <K1, Pr1>, P2, <K2, Pr2>, P3, <K3, Pr3> ..., <K(q-1), Pr(q-1)>, Pq>

            where q <= p,
            Pi - A tree node pointer
            Pri - Record pointer whose seach field value is Ki

        2. Within each node the record pointers are arranged in a sorted order of the key values.
            K1 < K2 < K3 < ... < K(q-1)

        3. The values of the record pointers in the child block that is pointed by the pointer in that parent node has values in the range between the record pointer adjacent to the block pointer in the parent node.
        4. Each node has atmost 'p' tree pointers
        5. Each node except the root node has atleast ceil(p/2) tree pointers
        6. A node with q tree pointers will have q-1 record pointers
        7. All leaf nodes are at the same level. LEaf nodes have the same strucutre as internal nodes except that all of their tree pointers are NULL.


B+Trees:
    -- In B+ Trees, data pointers are stored only at the leaf nodes of the tree; hence the structure of leaf nodes differs from the internal nodes.
    -- The leaf nodes have an entry for evey value of the search field along with either a record or a data pointer. 
    -- The leaf nodes of the B+trees are usually linked to provide ordered access on the search fields of the records. These leaf nodes are similar to the first level of an index.
    -- Internal nodes of B+tree correspond to the other level of multilevel index.
    -- Some of the search field values from th leaf node are repeated in the internodes of B+tree to guide the search.
    
    The structure of the internal nodes of a b+tree of order p is as follows:
        1. Each internal node is of the form
            <P1, K1, P2, K2, ... , Kq-1, Pq >
            Pi is a tree pointer
        2. Within each internal node, K1 < K2 < ... < Kq-1
        3 . The keys in the child block pointed by Pi tree pointer in the parent node has values in the range Ki-1 and Ki
        4. Each internal node has atmost p tree pointers
        5. Each internal node except the root, has atleast ceil(p/2) pointers.

    The structure of a leaf node in the B+tree of order p is as follows:
        1. Each leaf node is of the form
            <<K1, Pr1>, <K2, Pr2>, ... , <Kq-1, Prq-1>, Pnxt>
            Pri is a record pointer for the record that contains the searching field as Ki
            Pnxt is the pointer to the next leaf node of the B+Tree
        2. Each leaf nodes has atleast ceil(p/2) and atmost p-1 entries.
        3. All leaf nodes are at the same level

    -- Because entries in the inernal node sof a B+tree include seach values and tree pointer without an record ointer, more entries can be packed in the internal node of a B+ tree then a Btree. 
    -- Thus for the same block_size the B+Tree will have more order than a BTree.
    -- Because the structures of the internal and leaf node is different for a B+tree , the order p can be different
    -- We will use p to denote the order of the internal node and pleaf to denote the order of the leaf node in B+Tree

    for a given block_size we can find the expression for the order of the internal and leaf node as

        p*(P) + (p-1)*K <= B
        pleaf*(K+Pr) + P <= B

        p - Internal node order
        pleaf - Leaf node order
        P - Tree node pointer size
        Pr - Record pointer size
        K - Key field Size
        B - block_size 

Insertion:
    -- When a leaf node is full and a new entry is inserted here, the node overflows and must be split.
    -- The first j = ceil((p+1)/2) entries in the original node are kept and the remaining entries are moved to a new leaf node.
    -- The jth search value is replicated in the parent in the correct order.
    -- Now if the internal node is full, the new value will cause it to oveflow, so it must be split.
    -- The entries in the internal node up to j = floor((p+1)/2) are kept and the new node will hold the remaining entries. The jth search values is moved to the parent. 
    -- This process is propogated up as needed.

Deletion:
    -- When an entru is deleted, it is always removed from the lead level.
    -- If it happens to occur in an internal node, it is also removed and replaced by value to the left in the leaf node as it is now the rightmost value.
    -- Deletion may cause underflow by reducing the number of entries in the leaf node to below the minimum required.
    -- In this case we try to look for a sibling with more than minimum number of records and redistribute the records. If not then the nodes are merged and he number of lead nodes is reduced.

