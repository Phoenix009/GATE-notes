Informal Design Guidelines for Relation Schemas:
	-- Before discussing the formal theory of relational database design, we discuss four informal guidelines that may be used as measures to determine the quaity of relation schema design.

	1. Imparting clear semantics to attributes in Relations:
		-- The semantics of a relation refers to it meaning resulting from the interpretation of attribute values in a tuple.
		-- If the conceptual design is done carefully and mapping procedure is followed systematically then the relational schema design should have a clear meaning.
		-- The ease with which the meaning of a relations attributes can be explained is an informal measure of how well the relation is designed.

	2. Redundant information in tuples and update anomalies:
		-- One of the goal of the schema designs is to minimize the storage space used by the base relations.
		-- Storgina natural joins f base relations leads to additional problems refered to as update anomalies. these include insertion, deletion and update anomalies.
		-- Design the base relation schemas so that no anomalies are present in the relations.

	3. NULL values in tuples:
		-- As far as possible, avoid placing attributes in a base relation whose values may frequently be NULL.
		if NULLs are unavoidable, makes sure that they apply to exceptional cases and do not apply to majority of tuples in the relation.

	4. Generation of Spurious tuples:
		-- Design relation schemas so that they can be joined wth equality conditions on attributes (primary key, foreign key) that are appropriately related pairs in a way that can guarantee no spurious tuples.
		-- spurious tuple are the tuples that are generated by join operation that are not part of the either joining reltions. These tuples represent spurious information that is not valid.

Functional Dependencies:
	Definition: 
	-- denoted by X-->Y, between two sets of attributes that are subsets of R specifies that constraint on the possible tuples that can form the relational state r of R.
	-- That constraint is that for any two tuples t1 and t2
	if t1[X] == t2[X] ==> t1[Y] == t2[Y]
	-- Thus X functionally determines Y in a relation schema R iff whenever two tuples of r(R) agree on their X-value, they must necessarily agree on their Y-value.

	NOTE: 
	-- if X is a candidate key, which implies that X has unique values in R, this implies that X will functionally determine each and every attribute of R.
	This is because every value of X is distinct and thus there is no such case where the equality is violated.

	-- A functional dependency is  property of the relation schema R, not of a particular legal relation state r of R.
	-- Therefore an FD cannot be inferred automatically from a given relation extension r but must be defined explicitly by someone who knows the semantics of the attributes R.
	-- Given a particular relation, we cannot determine which FDs hold and which do not unless we know the attributes and meaning of the relationships among the attributes.
	-- All we can say that a certain FD may exists if it hold in that particular extension.

Types of Functional Dependencies:
	1. Trivial FDs:
		-- if A --> B and B is a subset of A then the Fd is said to be trivial.
		-- EX: (A, B, C) --> (B, c)
	
	2. NonTrivial Fds:
		-- if A --> B and A intersection B is NULL then the FD is said to be nontrivial
		-- EX: (A, B) --> C
	
	3. Semi Trivial FDs:
		-- If A --> B and A intersection B is not NULL and also B is not a subset of A then the FD is said to be semi trivial
		-- EX: (A, B) --> (B, C) 

Use Of Functional Dependencies:
	1. Identify Additional FDs
	2. Identify Keys
	3. Idntify Equivalence of FD sets
	4. Minimal / Canonical / Irreducible Cover

Armstrong Axioms:
	1. Reflexivity: If B is a subset of A then A --> B (Trivial FD)
	2. Transitivity: If A --> B and B --> C then A --> C
	3. Augmentation: if A --> B then (A, C) --> (B, C)
	4. Decomposition: If A --> (B, C) the  A --> B and A --> C
	5. Union: If A --> B and A --> C then A --> (B, C)
	6. Composition: If A --> B and C --> D then (A, C) --> (B, D)
  
Closure set of Attributes:

